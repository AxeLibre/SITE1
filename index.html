

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>AXEL LASALVIA  |  IT</title>
<link rel="icon" type="image/svg+xml" href="logo1.png">
<style>
  body { margin: 0; height: 600vh; overflow-x: hidden; background: #000;}
  canvas {
  position: fixed;
  top: 0;
  left: 0;
  display: block;
  opacity: 0;
  transition: opacity 1.2s ease;
}

  canvas.visible {
  opacity: 1;
}
</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.145.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/"
  }
}
</script>


<div id="scrollHint">‚¨áÔ∏è Scroll to Explore ‚¨áÔ∏è</div>

<!-- BULLE D'INFO -->
<div id="infoBubble">
  <img id="bubbleImage" />
  <div id="bubbleText"></div>
</div>




<style>
#scrollHint {
  position: fixed;
  bottom: 5%;          /* remonte un peu sur mobile */
  left: 50%;
  transform: translateX(-50%);
  font-size: clamp(14px, 4vw, 28px); /* min, adaptatif, max */
  padding: clamp(6px, 1.5vw, 12px) clamp(12px, 3vw, 24px);
  background: linear-gradient(
    135deg,
    rgba(0,255,255,0.25),
    rgba(255,0,255,0.25)
  );
  color:#091b29 ;
  text-shadow:
    0 1px 0 #1b3546db,
    0 2px 0 #262e69b3,
    0 3px 0 #4b36947c,
    0 4px 0 #cb53dd44;

  border-radius: 12px;
  text-align: center;
  z-index: 50;
  pointer-events: none; /* clic passe √† travers */
  font-family: 'Space Grotesk', system-ui, sans-serif;
  backdrop-filter: blur(5px);
  transition: opacity 0.5s, transform 0.5s;
  opacity: 1;
  pointer-events: none; /* pour ne pas g√™ner le scroll */
  z-index: 10;
   
}
#scrollHint.hidden {
  opacity: 0;
  transform: translateX(-50%) translateY(-20px);
}
</style>


<style>
#infoBubble {
  position: fixed;
  bottom: 40%;
  left: 50%;
  transform: translateX(-50%) translateY(20px);

  max-width: min(90vw, 900px);
  width: auto;

  max-height: 65vh; /* ‚¨ÖÔ∏è l√©g√®rement r√©duit */
  padding: clamp(12px, 3vw, 24px);
  border-radius: 18px;

  background: linear-gradient(
    135deg,
    rgba(0,255,255,0.18),
    rgba(255,0,255,0.18)
  );

  backdrop-filter: blur(12px);
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.15),
    0 20px 50px rgba(0,0,0,0.35);

  display: flex;
  flex-direction: column;
  gap: 12px;

  overflow: hidden;

  opacity: 0;
  pointer-events: none;

  transition: opacity 0.45s ease, transform 0.45s ease;
  z-index: 30;
}

#bubbleText a {
  position: relative;
}

#bubbleText a::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: -2px;
  width: 100%;
  height: 1px;
  background: currentColor;
  transform: scaleX(0);
  transition: transform 0.25s ease;
}

#bubbleText a:hover::after {
  transform: scaleX(1);
}


/* √âTAT VISIBLE */
#infoBubble.visible {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
  pointer-events: auto;
}



#bubbleText {
  font-size: clamp(17px, 2.5vh, 20px);
  line-height: 1.5;
  font-family: 'Space Grotesk', system-ui, sans-serif;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);

  width: 100%;
  max-width: 60ch;

  overflow: visible; /* supprime la barre de d√©filement */
  padding-right: 6px;

  mask-image: linear-gradient(
    to bottom,
    black 100%,
    transparent
  );
}


#bubbleImage {
  max-height: 35vh;     /* üî• ne d√©passe jamais en haut */
  width: auto;
  max-width: 100%;

  object-fit: contain;
  display: block;
  margin: 0 auto;

  border-radius: 8px;
  flex-shrink: 0;       /* üî• emp√™che l‚Äô√©crasement */
}


#infoBubble.show {
  display: flex;   /* la m√™me que flex-direction: column; */
  opacity: 1;
}

.youtube-wrapper {
  position: relative;
  width: 100%;
  padding-top: 56.25%; /* 16:9 */
}

.youtube-wrapper iframe {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border: 0;
}


</style>






<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

let ready = true; // Indicateur pour le rendu (fin de chargement de la sc√®ne)
let firstFrame = true;  // premi√®re frame cam√©ra (anti-rotation parasite)
let voxelCube = null;
const COUNT = 1000;
const SPACING = 2;
const cubes = [];
let shapes = [];









// === CUBES SUIVANT LA SOURIS ===
const mouseCubes = [];
const MOUSE_CUBE_COUNT = 15;
const MOUSE_DELAY_FACTOR = 0.1; // Plus petit = plus de retard
let mousePosition = new THREE.Vector2(0, 0);
let targetMousePosition = new THREE.Vector2(0, 0);
let lastTime = 0;



// === INITIALISATION ===
const scene = new THREE.Scene();



// ===============================
// √âCRAN VID√âO + CADRE M√âTALLIQUE
// ===============================

const screenx = 0;  // POSITION √âCRAN X
const screeny = 0;  // POSITION √âCRAN Y
const screenz = -50;  // POSITION √âCRAN Z

// --- Vid√©o ---
const screenVideo = document.createElement('video');
screenVideo.src = "videos/video3d1.mp4";
screenVideo.loop = true;
screenVideo.muted = true;
screenVideo.playsInline = true;
screenVideo.autoplay = true;
screenVideo.play();

// --- Texture vid√©o ---
const screenTexture = new THREE.VideoTexture(screenVideo);
screenTexture.colorSpace = THREE.SRGBColorSpace;

// --- Groupe √©cran (IMPORTANT) ---
const screenGroup = new THREE.Group();
scene.add(screenGroup);


// --- Dimensions √©cran ---
const screenWidth = 30;
const screenHeight = 17;
const screenDepth = 0.1;

// --- Mesh √©cran ---
const screenMesh = new THREE.Mesh(
  new THREE.BoxGeometry(screenWidth, screenHeight, screenDepth),
  new THREE.MeshStandardMaterial({
    map: screenTexture,
    roughness: 0,
    metalness: 0.5
  })

);
screenMesh.position.set(screenx, screeny, screenz); // position vid√©o √©cran
screenMesh.rotation.y = Math.PI / 1; // l√©g√®re rotation pour meilleure visibilit√©

screenGroup.add(screenMesh);

// --- Mat√©riau cadre ---
const frameMaterial = new THREE.MeshStandardMaterial({
  color: 0x888888,
  metalness: 0.9,
  roughness: 0.1
  
});

const frameThickness = 2;
const frameDepth = 4;

// --- Haut ---
const frameTop = new THREE.Mesh(
  new THREE.BoxGeometry(screenWidth + frameThickness * 2, frameThickness, frameDepth),
  frameMaterial
);
frameTop.position.y = screenHeight / 2 + frameThickness / 2;

// --- Bas ---
const frameBottom = frameTop.clone();
frameBottom.position.y = -screenHeight / 2 - frameThickness / 2;

// --- Gauche ---
const frameLeft = new THREE.Mesh(
  new THREE.BoxGeometry(frameThickness, screenHeight, frameDepth),
  frameMaterial
);
frameLeft.position.x = -screenWidth / 2 - frameThickness / 2;

// --- Droite ---
const frameRight = frameLeft.clone();
frameRight.position.x = screenWidth / 2 + frameThickness / 2;

// --- Ajout cadre ---
screenGroup.add(frameTop, frameBottom, frameLeft, frameRight);

// --- Position globale √©cran ---
screenGroup.position.set(screenx, screeny, screenz);
screenGroup.rotation.y = Math.PI / 1; // m√™me rotation que le mesh pour rester align√©

// On s'assure que le groupe est invisible au d√©part
screenGroup.visible = false;

function setScreen(on) {
  screenMesh.visible = on;
  frameTop.visible = on;
  frameBottom.visible = on;
  frameLeft.visible = on;
  frameRight.visible = on;
}
setScreen(false);


window.addEventListener("scroll", () => {
  const scrollTop = window.scrollY;
  const docHeight = document.body.scrollHeight - window.innerHeight;
  const scrollFraction = docHeight > 0 ? scrollTop / docHeight : 0;

  setScreen(scrollFraction >= 0.5);
});




// === CAM√âRA & RENDERER ===

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 3, 6);
const cameraAnchor = new THREE.Group();
camera.add(cameraAnchor);
scene.add(camera);
scene.add(screenMesh);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

// --- RESPONSIVE / ADAPTATION HORIZONTALIT√â ---
window.addEventListener('resize', onWindowResize);

function onWindowResize() {
    // --- Adapter la taille du canvas ---
    renderer.setSize(window.innerWidth, window.innerHeight);

    // --- Adapter le ratio cam√©ra ---
    camera.aspect = window.innerWidth / window.innerHeight;

    // Limite du ratio pour √©viter trop d'√©tirement sur √©cran ultra-large
    const maxAspect = 2; // maximum 2:1
    if (camera.aspect > maxAspect) camera.aspect = maxAspect;

    camera.updateProjectionMatrix();

    // --- Ajuster la position de la cam√©ra selon ratio √©cran ---
    const ratio = window.innerWidth / window.innerHeight;

    if (ratio > 2) {
        // √©cran tr√®s large ‚Üí reculer la cam√©ra et augmenter radius
        camera.position.z = 8;
    } else {
        // √©cran normal ‚Üí valeurs par d√©faut
        camera.position.z = 6;
    }
}


// === LUMI√àRES ===
scene.add(new THREE.AmbientLight(0x444444, 0.1));
const pointLight = new THREE.PointLight(0xffffff, 0.1);
pointLight.position.set(3, 5, 3);
scene.add(pointLight);

// === ENVIRONNEMENT ===
const VERSION = "v3";
const envPath = "./env4/";
const envFiles = ["px", "nx", "py", "ny", "pz", "nz"].map(f => envPath + f + ".jpg");
const envMap = new THREE.CubeTextureLoader().load(envFiles);

envMap.colorSpace = THREE.SRGBColorSpace;

scene.background = envMap;
scene.environment = envMap;

renderer.toneMappingExposure = 0.8;

//===Scroll Hint===
const scrollHint = document.getElementById('scrollHint');

window.addEventListener('scroll', () => {
  if (window.scrollY > 10) { // d√®s que l'utilisateur commence √† scroller
    scrollHint.classList.add('hidden');
  } else {
    scrollHint.classList.remove('hidden');
  }
});


/*
// === GOUTTE ===
let dropModel = null;
const loader = new GLTFLoader();
loader.load(
  "drop_of_water.glb",
  (gltf) => {
    dropModel = gltf.scene;
    dropModel.scale.set(0.5, 0.5, 0.5);
    dropModel.position.set(0, -5, 0);

    dropModel.traverse((child) => {
      if (child.isMesh) {
        child.material.color.set(0x55aaff);
        child.material.envMap = envMap;
        child.material.envMapIntensity = 0.9;
        child.material.metalness = 0.4;
        child.material.roughness = 0.2;
        child.material.needsUpdate = true;
      }
    });

    scene.add(dropModel);
    

    smoothScroll = scrollFactor;

    const dropStartY = 8;           
    const dropEndY = -8;
    dropModel.position.y =
        dropStartY + smoothScroll * (dropEndY - dropStartY);  //  position initiale CORRECTE


    // --- SYNCHRO CAM√âRA AVANT FADE ---
    const sf = scrollFactor;

    // m√™me logique que dans animate()
    const radius = (window.innerWidth / window.innerHeight > 2) ? 5 : 4;
    const angle = sf * Math.PI * 2.5;

    const camHeightStart = 4;
    const camHeightEnd = -3;
    const camY = camHeightStart + sf * (camHeightEnd - camHeightStart);

    camera.position.set(
    Math.sin(angle) * radius,
    camY,
    Math.cos(angle) * radius
    );

    camera.lookAt(0, dropModel.position.y, 0);

    ready = true; // sc√®ne charg√©e pour fondu noir
    onWindowResize(); // assure le bon ratio initial
  },
  undefined,
  (err) => console.error("Erreur GLB :", err)
);


*/



const cubeGroup = new THREE.Group();
scene.add(cubeGroup); // ajoute le groupe √† la sc√®ne



// FORMES
function generateCubeShape(){
  const arr = [];
  let idx=0;
  for(let x=0;x<10;x++){
    for(let y=0;y<10;y++){
      for(let z=0;z<10;z++){
        arr[idx++] = {x:(x-5)*SPACING, y:(y-5)*SPACING, z:(z-5)*SPACING};
      }
    }
  }
  return arr;
}
function generateCloudShape(count, size=30){
  const arr=[];
  for(let i=0;i<count;i++){
    arr.push({x:(Math.random()-0.5)*size, y:(Math.random()-0.5)*size, z:(Math.random()-0.5)*size});
  }
  return arr;
}






// COMPUTER SHAPE (ordinateur portable avec √©cran + clavier)

function generateComputerShape(count = 1000, rotation = 0) {
  const arr = [];
  const SCALE = 2; // Scale x2
  const radRotation = rotation * Math.PI / 180;
  const cosRot = Math.cos(radRotation);
  const sinRot = Math.sin(radRotation);

  // --- Rotation X -90¬∞ (vue de c√¥t√©) ---
  const rotateXMinus90 = (point) => ({ x: point.x, y: point.z, z: -point.y });

  // --- Rotation vers l'avant / inclinaison 
  const TILT = 0.22;

  const tiltForward = (p) => ({
    x: p.x,
    y: p.y * Math.cos(TILT) - p.z * Math.sin(TILT),
    z: p.y * Math.sin(TILT) + p.z * Math.cos(TILT)
  });


  // --- Dimensions ---
  const baseWidth = 12;
  const baseDepth = 8;
  const baseHeight = 0.5;

  const screenWidth = baseWidth;
  const screenHeight = 6;
  const screenDepth = 0.5;
  const tiltAngle = -15 * Math.PI / 180; // inclinaison √©cran

  const rowsKeys = 5; // Clavier
  const colsKeys = 10;

    // Pour d√©placer TOUT l'ordinateur, ajouter un offset :
  const OFFSET_X = 0; // ‚Üê D√©calage X
  const OFFSET_Y = 0; // ‚Üê D√©calage Y
  const OFFSET_Z = 0; // ‚Üê D√©calage Z


  // --- Nombre de points par zone ---
  const basePoints = Math.floor(count * 0.3);
  const screenPoints = Math.floor(count * 0.35);
  const keysPoints = count - basePoints - screenPoints;

  // --- Base : grille r√©guli√®re ---
  const baseRows = Math.floor(Math.sqrt(basePoints));
  const baseCols = Math.floor(basePoints / baseRows);
  for (let r = 0; r < baseRows; r++) {
    for (let c = 0; c < baseCols; c++) {
      const x = -baseWidth / 2 + (c + 0.5) * (baseWidth / baseCols);
      const y = -baseDepth / 2 + (r + 0.5) * (baseDepth / baseRows);
      const z = baseHeight / 2;

      let finalX = x * SCALE * cosRot - y * SCALE * sinRot + OFFSET_X;
      let finalY = x * SCALE * sinRot + y * SCALE * cosRot + OFFSET_Y;
      let finalZ = z * SCALE + OFFSET_Z;

      arr.push(tiltForward(rotateXMinus90({ x: finalX, y: finalY, z: finalZ })));
    }
  }

  // --- √âcran : grille r√©guli√®re coll√© √† l'arri√®re ---
  const screenRows = Math.floor(Math.sqrt(screenPoints));
  const screenCols = Math.floor(screenPoints / screenRows);
  const baseRearY = baseDepth / 2;
  for (let r = 0; r < screenRows; r++) {
    for (let c = 0; c < screenCols; c++) {
      const x = -screenWidth / 2 + (c + 0.5) * (screenWidth / screenCols);
      const y = baseRearY + screenDepth / 2; // coll√© √† l'arri√®re
      const z = (r + 0.5) * (screenHeight / screenRows);

      // Inclinaison
      const zInclined = z * Math.cos(tiltAngle) - y * Math.sin(tiltAngle);
      const yInclined = z * Math.sin(tiltAngle) + y * Math.cos(tiltAngle);

      let finalX = x * SCALE * cosRot - yInclined * SCALE * sinRot + OFFSET_X;
      let finalY = x * SCALE * sinRot + yInclined * SCALE * cosRot + OFFSET_Y;
      let finalZ = zInclined * SCALE + OFFSET_Z;

      arr.push(tiltForward(rotateXMinus90({ x: finalX, y: finalY, z: finalZ })));
    }
  }

  // --- Clavier : grille centr√©e et touches plus hautes ---
  const keyRows = rowsKeys;
  const keyCols = colsKeys;
  const pointsPerKey = Math.floor(keysPoints / (keyRows * keyCols));


  const keyOffsetX = baseWidth / (keyCols * 16); // D√©calage d‚Äôune demi-case
  const keyHeight = 0; // Rehausse les touches
  const keyboardInset = baseDepth * 0.07; // ‚Üê recule le clavier (ajuste ici)


  for (let r = 0; r < keyRows; r++) {
    for (let c = 0; c < keyCols; c++) {
      for (let k = 0; k < pointsPerKey; k++) {
        const x = -baseWidth / 2 + (c + 0.5) * (baseWidth / keyCols) + keyOffsetX + (Math.random() - 0.5) * 0.2;
        const y =
        -baseDepth / 2 +
        keyboardInset +
        (r + 0.5) * ((baseDepth - keyboardInset) / keyRows) +
        (Math.random() - 0.5) * 0.15;

        const z = baseHeight + keyHeight + 0.05 * Math.random(); // plus hautes touches

        let finalX = x * SCALE * cosRot - y * SCALE * sinRot + OFFSET_X;
        let finalY = x * SCALE * sinRot + y * SCALE * cosRot + OFFSET_Y;
        let finalZ = z * SCALE + OFFSET_Z;

        arr.push(tiltForward(rotateXMinus90({ x: finalX, y: finalY, z: finalZ })));
      }
    }
  }

  while (arr.length < count) {
  arr.push(arr[arr.length - 1]);
}
  return arr;

}

// --- Utilisation ---
const computerGridImproved = generateComputerShape(1000, 0);
console.log("Ordinateur grille am√©lior√©:", computerGridImproved.length, "points");



// Ajouter l'√©cran vid√©o
scene.add(screenMesh);









// -------------------------
// WiFi Shape Generator
// -------------------------
function generateWifiShapeUp(count = 1000, rotation = 0) {
  const arr = [];
  const SCALE = 5;

  const radRotation = rotation * Math.PI / 180;
  const cosRot = Math.cos(radRotation);
  const sinRot = Math.sin(radRotation);

  // Cercle central
  const centerPoints = Math.floor(count * 0.15);
  for (let i = 0; i < centerPoints; i++) {
    const angle = (i / centerPoints) * 2 * Math.PI;
    const x = Math.cos(angle) * 0.7;
    const y = Math.sin(angle) * 0.7;

    const scaledX = x * SCALE;
    const scaledY = y * SCALE;

    // Rotation utilisateur seulement (plus de +180)
    const finalX = scaledX * cosRot - scaledY * sinRot;
    const finalY = scaledX * sinRot + scaledY * cosRot;

    arr.push({ x: finalX, y: finalY, z: 0 });
  }

  // Arcs concentriques
  const arcs = [
    { radius: 2.0, width: 0.4, startAngle: Math.PI * 0.7, endAngle: Math.PI * 0.3 },
    { radius: 3.0, width: 0.4, startAngle: Math.PI * 0.75, endAngle: Math.PI * 0.25 },
    { radius: 4.0, width: 0.4, startAngle: Math.PI * 0.8, endAngle: Math.PI * 0.2 },
  ];

  const pointsPerArc = Math.floor((count - centerPoints) / arcs.length);

  arcs.forEach((arc) => {
    for (let i = 0; i < pointsPerArc; i++) {
      const angle = arc.startAngle + (arc.endAngle - arc.startAngle) * (i / pointsPerArc);
      const r = arc.radius + (Math.random() - 0.5) * arc.width;
      const x = Math.cos(angle) * r;
      const y = Math.sin(angle) * r;

      const scaledX = x * SCALE;
      const scaledY = y * SCALE;

      const finalX = scaledX * cosRot - scaledY * sinRot;
      const finalY = scaledX * sinRot + scaledY * cosRot;

      arr.push({ x: finalX, y: finalY, z: 0 });
    }
  });

  // Compl√©ter si n√©cessaire
  while (arr.length < count) {
    const arc = arcs[2];
    const angle = arc.startAngle + Math.random() * (arc.endAngle - arc.startAngle);
    const r = arc.radius + (Math.random() - 0.5) * arc.width;

    const x = Math.cos(angle) * r;
    const y = Math.sin(angle) * r;

    const scaledX = x * SCALE;
    const scaledY = y * SCALE;

    const finalX = scaledX * cosRot - scaledY * sinRot;
    const finalY = scaledX * sinRot + scaledY * cosRot;

    arr.push({ x: finalX, y: finalY, z: 0 });
  }

  return arr.slice(0, count);
}

function generateRouterShape(count = 1000, rotation = 0) {
  return generateWifiShapeUp(count, rotation);
}













function generateAtShape(count = 1000) {
  const arr = [];
  const SCALE = 4;
  const AT_OFFSET = {
    x: 0,
    y: 1.5
  };


  /* =========================
     PARAM√àTRES √Ä AJUSTER
  ========================= */

  const BAR = {
    ratio: 0.25,          // % de cubes
    x: 1.6,
    yMin: -2.0,
    yMax: 1.8,
    rotation: 0,
    offsetX: 0.5,
    scale: 0.9
  };

  const SMALL_ARC = {
    ratio: 0.30,
    radius: 2.0,
    startAngle: Math.PI * 1.3,
    endAngle: Math.PI * 2.7,
    offsetX: 0,
    offsetY: 0.2,
    rotation: Math.PI ,
    scale: 1
  };

  const SPIRAL = {
    ratio: 0.45,            // % de cubes
    startRadius: 2,       // doit √™tre tr√®s proche du petit arc
    endRadius: 4,         // taille globale du @
    turns: 1,            // nombre de tours (1.1 ‚Üí 1.4 recommand√©)
    startAngle: Math.PI * 1.9,
    offsetX: 0,
    offsetY: 0,
    rotation: -Math.PI / 10,
    scale: 1
  };

  /* =========================
     UTILS
  ========================= */

  const push = (x, y, rot = 0, scale = 1) => {
    const sx = x * scale * SCALE;
    const sy = y * scale * SCALE;

    const cos = Math.cos(rot);
    const sin = Math.sin(rot);

    arr.push({
      x: sx * cos - sy * sin,
      y: sx * sin + sy * cos,
      z: (Math.random() - 0.5) * 0.15
    });
  };

  const pushAt = (x, y, rot = 0, scale = 1) => {
    const sx = x * scale * SCALE;
    const sy = y * scale * SCALE;

    const cos = Math.cos(rot);
    const sin = Math.sin(rot);

    // rotation
    const rx = sx * cos - sy * sin;
    const ry = sx * sin + sy * cos;

    // ‚úÖ offset APRES rotation
    arr.push({
      x: rx + AT_OFFSET.x * SCALE,
      y: ry + AT_OFFSET.y * SCALE,
      z: (Math.random() - 0.5) * 0.15
    });
  };


  /* =========================
     1Ô∏è‚É£ BARRE
  ========================= */

  const barCount = Math.floor(count * BAR.ratio);
  for (let i = 0; i < barCount; i++) {
    const t = i / barCount;
    pushAt(
      BAR.x + (Math.random() - 0.5) * 0.12,
      BAR.yMin + t * (BAR.yMax - BAR.yMin),
      BAR.rotation,
      BAR.scale
    );

  }

  /* =========================
     2Ô∏è‚É£ PETIT ARC
  ========================= */

  const smallArcCount = Math.floor(count * SMALL_ARC.ratio);
  for (let i = 0; i < smallArcCount; i++) {
    const t = i / smallArcCount;
    const a = SMALL_ARC.startAngle +
              t * (SMALL_ARC.endAngle - SMALL_ARC.startAngle);

    pushAt(
      Math.cos(a) * SMALL_ARC.radius + SMALL_ARC.offsetX,
      Math.sin(a) * SMALL_ARC.radius + SMALL_ARC.offsetY,
      SMALL_ARC.rotation,
      SMALL_ARC.scale
    );

  }

  /* =========================
    3Ô∏è‚É£ SPIRALE (@ ext√©rieur)
  ========================= */

  const spiralCount = count - arr.length;

  for (let i = 0; i < spiralCount; i++) {
    const t = i / spiralCount;

    // Angle progressif
    const angle =
      SPIRAL.startAngle +
      t * Math.PI * 2 * SPIRAL.turns;

    // Rayon progressif (spirale)
    const radius =
      SPIRAL.startRadius +
      t * (SPIRAL.endRadius - SPIRAL.startRadius);

    pushAt(
      Math.cos(angle) * radius + SPIRAL.offsetX,
      Math.sin(angle) * radius + SPIRAL.offsetY,
      SPIRAL.rotation,
      SPIRAL.scale
    );

  }
  return arr;

}








function generateCodeSymbolShape(count = 1000) {
  const arr = [];
  const SCALE = 2;

  /* =========================
     PARAM√àTRES
  ========================= */
  const LEFT_CHEVRON = {
    ratio: 0.35,
    width: 2.0,
    height: 3.0,
    offsetX: 4,   // √† gauche
    offsetY: 0,
    rotation: Math.PI,
    scale: 1.5
  };

  const RIGHT_CHEVRON = {
    ratio: 0.35,
    width: 2.0,
    height: 3.0,
    offsetX: -4,   // √† droite
    offsetY: 0,
    rotation: Math.PI,
    scale: 1.5
  };

  const BAR = {
    ratio: 0.3,
    width: 0.1,
    height: 4,
    offsetX: 0,
    offsetY: 0,
    rotation: -Math.PI / 8,
    scale: 2
  };

  const push = (x, y, rot = 0, scale = 1) => {
    const sx = x * scale * SCALE;
    const sy = y * scale * SCALE;
    const cos = Math.cos(rot);
    const sin = Math.sin(rot);
    arr.push({
      x: sx * cos - sy * sin,
      y: sx * sin + sy * cos,
      z: (Math.random() - 0.5) * 0.15
    });
  };

  /* =========================
     CHEVRON GAUCHE
  ========================= */
  const leftCount = Math.floor(count * LEFT_CHEVRON.ratio / 2);
  for (let i = 0; i < leftCount; i++) {
    const t = i / (leftCount - 1);
    push(
      LEFT_CHEVRON.offsetX - t * LEFT_CHEVRON.width,
      LEFT_CHEVRON.offsetY - t * LEFT_CHEVRON.height,
      LEFT_CHEVRON.rotation,
      LEFT_CHEVRON.scale
    );
    push(
      LEFT_CHEVRON.offsetX - t * LEFT_CHEVRON.width,
      LEFT_CHEVRON.offsetY + t * LEFT_CHEVRON.height,
      LEFT_CHEVRON.rotation,
      LEFT_CHEVRON.scale
    );
  }

  /* =========================
     CHEVRON DROIT
     (d√©cal√© pour ne pas superposer)
  ========================= */
  const rightCount = Math.floor(count * RIGHT_CHEVRON.ratio / 2);
  for (let i = 0; i < rightCount; i++) {
    const t = i / (rightCount - 1);
    push(
      RIGHT_CHEVRON.offsetX + t * RIGHT_CHEVRON.width,  // d√©calage droit
      RIGHT_CHEVRON.offsetY - t * RIGHT_CHEVRON.height,
      RIGHT_CHEVRON.rotation,
      RIGHT_CHEVRON.scale
    );
    push(
      RIGHT_CHEVRON.offsetX + t * RIGHT_CHEVRON.width,
      RIGHT_CHEVRON.offsetY + t * RIGHT_CHEVRON.height,
      RIGHT_CHEVRON.rotation,
      RIGHT_CHEVRON.scale
    );
  }

  /* =========================
     BARRE CENTRALE
  ========================= */
  const barCount = count - arr.length;
  for (let i = 0; i < barCount; i++) {
    const t = i / barCount;
    const x = BAR.offsetX + (Math.random() - 0.5) * BAR.width;
    const y = BAR.offsetY - BAR.height / 2 + t * BAR.height;
    push(x, y, BAR.rotation, BAR.scale);
  }

  return arr.slice(0, count);
}

// --- Utilisation ---
const codeSymbol = generateCodeSymbolShape(1000);
console.log("Code symbol points:", codeSymbol.length);











// C≈ìur ‚ù§Ô∏è
function generateHeartShape(count = 1000, rotation = 0) {
  const arr = [];
  const SCALE = 20;
  
  // Convertir la rotation en radians
  const radRotation = rotation * Math.PI / 180;
  const cosRot = Math.cos(radRotation);
  const sinRot = Math.sin(radRotation);
  
  // G√©n√©rer les points sans rotation
  const rawPoints = [];
  const layers = 8; // Plus de couches pour plus de volume
  const pointsPerLayer = Math.floor(count / layers);
  
  for (let layer = 0; layer < layers; layer++) {
    const z = (layer - layers/2) * 0.4; // √âpaisseur r√©duite
    
    for (let i = 0; i < pointsPerLayer; i++) {
      const angle = (i / pointsPerLayer) * 2 * Math.PI;
      
      // Formule param√©trique am√©lior√©e du c≈ìur
      const t = angle;
      
      // √âquation classique du c≈ìur mais ajust√©e
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      
      // Normaliser et ajuster l'√©chelle
      const heartX = x / 20; // Normaliser √† environ -1 √† 1
      const heartY = y / 20; // Normaliser √† environ -1.5 √† 1.2
      
      // Ajuster la forme pour plus de courbe
      // - L√©g√®re compression horizontale
      // - Ajustement vertical pour la pointe
      const adjustedX = heartX * 0.9;
      
      // Pour la partie sup√©rieure, cr√©er plus de courbe
      let adjustedY;
      if (heartY > 0) {
        // Partie sup√©rieure (les lobes) - plus arrondie
        adjustedY = heartY * 1.1;
      } else {
        // Partie inf√©rieure (la pointe) - plus douce
        adjustedY = heartY * 0.8;
      }
      
      // D√©placer vers le haut pour centrer
      adjustedY = adjustedY - 0.3;
      
      // Appliquer l'√©chelle
      const scaledX = adjustedX * SCALE;
      const scaledY = adjustedY * SCALE;
      
      rawPoints.push({ 
        x: scaledX, 
        y: scaledY, 
        z: z 
      });
    }
  }
  
  // Points pour l'int√©rieur du c≈ìur (plus denses)
  const innerPoints = Math.floor(count * 0.3);
  for (let i = 0; i < innerPoints; i++) {
    // Points al√©atoires √† l'int√©rieur du c≈ìur
    const r = Math.sqrt(Math.random()) * 0.7; // Distribution radiale
    const angle = Math.random() * 2 * Math.PI;
    
    // Calculer la position sur le contour
    const t = angle;
    const contourX = 16 * Math.pow(Math.sin(t), 3) / 20;
    const contourY = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 20;
    
    // Ajustements similaires
    const adjustedContourX = contourX * 0.9;
    let adjustedContourY;
    if (contourY > 0) {
      adjustedContourY = contourY * 1.1 - 0.3;
    } else {
      adjustedContourY = contourY * 0.8 - 0.3;
    }
    
    // Point int√©rieur (interpolation vers le centre)
    const x = adjustedContourX * r * SCALE;
    const y = adjustedContourY * r * SCALE;
    const z = (Math.random() - 0.5) * 1.2; // Z al√©atoire pour le volume
    
    rawPoints.push({ x: x, y: y, z: z });
  }
  
  // Appliquer la rotation et ajouter aux points finaux
  for (const point of rawPoints) {
    let x = point.x;
    let y = point.y;
    
    // Appliquer rotation si n√©cessaire
    if (rotation !== 0) {
      const tempX = x;
      x = x * cosRot - y * sinRot;
      y = tempX * sinRot + y * cosRot;
    }
    
    // L√©g√®re variation al√©atoire pour un look organique
    arr.push({
      x: x + (Math.random() - 0.5) * 0.15,
      y: y + (Math.random() - 0.5) * 0.15,
      z: point.z + (Math.random() - 0.5) * 0.1
    });
    
    // Arr√™ter si on a atteint le compte
    if (arr.length >= count) break;
  }
  
  // Compl√©ter si n√©cessaire avec des points simples
  while (arr.length < count) {
    // Points sur le contour pour garantir la forme
    const angle = Math.random() * 2 * Math.PI;
    const t = angle;
    
    const x = 16 * Math.pow(Math.sin(t), 3) / 20;
    const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 20;
    
    // Ajustements
    const adjustedX = x * 0.9;
    let adjustedY;
    if (y > 0) {
      adjustedY = y * 1.1 - 0.3;
    } else {
      adjustedY = y * 0.8 - 0.3;
    }
    
    let finalX = adjustedX * SCALE;
    let finalY = adjustedY * SCALE;
    
    // Rotation
    if (rotation !== 0) {
      const tempX = finalX;
      finalX = finalX * cosRot - finalY * sinRot;
      finalY = tempX * sinRot + finalY * cosRot;
    }
    
    arr.push({
      x: finalX,
      y: finalY,
      z: (Math.random() - 0.5) * 0.8
    });
  }
  
  // Tronquer au count exact
  return arr.slice(0, count);
}

// Utilisations:
const heartNormal = generateHeartShape(1000, 0); // C≈ìur normal orient√© vers le haut
const heartRotated90 = generateHeartShape(1000, 90); // C≈ìur tourn√© de 90¬∞
const heartRotated180 = generateHeartShape(1000, 180); // C≈ìur √† l'envers






/*
// === CR√âATION DES CUBES DE SOURIS ===
function createMouseCubes() {
  const geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
  
  for (let i = 0; i < MOUSE_CUBE_COUNT; i++) {
    // D√©grad√© cyan (0.5) vers magenta (0.8)
    const hue = 0.5 + (0.8 - 0.5) * (i / MOUSE_CUBE_COUNT);
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color().setHSL(hue, 1, 0.5),
      metalness: 0.95,
      roughness: 0.05,
      transparent: true,
      opacity: 0.8 - (i / MOUSE_CUBE_COUNT) * 0.6
    });
    
    const cube = new THREE.Mesh(geometry, material);
    
    // Position initiale
    cube.position.set(0, 0, 0);
    
    // Propri√©t√©s pour l'animation
    cube.userData = {
      index: i,
      delay: i * 0.07, // D√©lai progressif
      speed: 0.8 + (i / MOUSE_CUBE_COUNT) * 0.5, // Vitesse variable
      pathPoints: [], // Historique des positions
      maxPathLength: 20, // Nombre max de points dans l'historique
      currentTarget: new THREE.Vector3(0, 0, 0),
      springFactor: 0.15 + (i / MOUSE_CUBE_COUNT) * 0.1, // Facteur ressort
      noiseOffset: Math.random() * 1000, // Offset pour le bruit
      orbitRadius: 0.3 + (i / MOUSE_CUBE_COUNT) * 1.5, // Rayon d'orbite
      orbitSpeed: 0.5 + (i / MOUSE_CUBE_COUNT) * 2 // Vitesse d'orbite
    };
    
    scene.add(cube);
    mouseCubes.push(cube);
  }
}

// Appeler la fonction apr√®s avoir cr√©√© les autres cubes
createMouseCubes();



// === FONCTION POUR METTRE √Ä JOUR LES CUBES DE SOURIS (version zonale) ===
function updateMouseCubes(deltaTime) {
  // Lissage de la position de la souris
  mousePosition.x += (targetMousePosition.x - mousePosition.x) * 0.1;
  mousePosition.y += (targetMousePosition.y - mousePosition.y) * 0.1;
  
  // Calculer la position cible principale
  const vector = new THREE.Vector3(mousePosition.x, mousePosition.y, 0.5);
  vector.unproject(camera);
  
  const direction = vector.sub(camera.position).normalize();
  const distance = 2;
  const baseTarget = camera.position.clone().add(direction.multiplyScalar(distance));
  
  const time = Date.now() * 0.001;
  
  // Pour chaque cube
  mouseCubes.forEach((cube, index) => {
    const distanceFactor = index / MOUSE_CUBE_COUNT;
    
    // D√âFINIR DES ZONES DE COMPORTEMENT
    let behavior;
    if (distanceFactor < 0.3) {
      // ZONE 1: Cubes proches (0-30%) - Mouvement vif et pr√©cis
      behavior = {
        movementScale: 1.0,
        speed: 1.0,
        lerpSpeed: 0.15,
        rotationSpeed: 0.02,
        waveAmplitude: 0.04,
        spiralRadius: 0.12,
        historyLength: 12
      };
    } else if (distanceFactor < 0.7) {
      // ZONE 2: Cubes interm√©diaires (30-70%) - Mouvement mod√©r√©
      behavior = {
        movementScale: 0.5,
        speed: 0.7,
        lerpSpeed: 0.1,
        rotationSpeed: 0.01,
        waveAmplitude: 0.03,
        spiralRadius: 0.07,
        historyLength: 9
      };
    } else {
      // ZONE 3: Cubes lointains (70-100%) - Mouvement tr√®s subtil
      behavior = {
        movementScale: 0.2,
        speed: 0.4,
        lerpSpeed: 0.06,
        rotationSpeed: 0.005,
        waveAmplitude: 0.02,
        spiralRadius: 0.03,
        historyLength: 6
      };
    }
    
    // 1. Position de r√©f√©rence
    let referencePos;
    if (index === 0) {
      referencePos = baseTarget.clone();
    } else {
      const prevCube = mouseCubes[index - 1];
      referencePos = prevCube.position.clone();
      
      // Utiliser l'historique pour plus de fluidit√©
      if (prevCube.userData.pathPoints && prevCube.userData.pathPoints.length > 0) {
        const delay = Math.floor(behavior.historyLength * 0.3);
        const delayedIndex = Math.min(delay, prevCube.userData.pathPoints.length - 1);
        referencePos = prevCube.userData.pathPoints[delayedIndex].clone();
      }
    }
    
    // 2. Mouvements (tr√®s att√©nu√©s pour la zone 3)
    const spiralAngle = time * behavior.speed * 2 + index * 0.15;
    const spiralX = Math.cos(spiralAngle) * behavior.spiralRadius;
    const spiralY = Math.sin(spiralAngle * 1.2) * behavior.spiralRadius * 0.5;
    const spiralZ = Math.sin(spiralAngle * 0.9) * behavior.spiralRadius;
    
    const waveY = Math.sin(time * behavior.speed * 3 + index) * behavior.waveAmplitude;
    
    // 3. Cible finale
    const targetPos = new THREE.Vector3(
      referencePos.x + spiralX,
      referencePos.y + spiralY + waveY,
      referencePos.z + spiralZ
    );
    
    // 4. D√©placement
    cube.position.lerp(targetPos, behavior.lerpSpeed);
    
    // 5. Gestion historique
    if (!cube.userData.pathPoints) {
      cube.userData.pathPoints = [];
    }
    cube.userData.pathPoints.unshift(cube.position.clone());
    if (cube.userData.pathPoints.length > behavior.historyLength) {
      cube.userData.pathPoints.pop();
    }
    
    // 6. Rotation
    cube.rotation.x += behavior.rotationSpeed;
    cube.rotation.y += behavior.rotationSpeed * 1.1;
    
    // 7. √âchelle
    const baseScale = 0.8 - distanceFactor * 0.5;
    cube.scale.setScalar(baseScale);
    
    // 8. Opacit√©
    const opacity = 0.9 - distanceFactor * 0.7;
    cube.material.opacity = opacity;
  });
}

*/



shapes = [
  generateCubeShape(),        // 0: cube 10x10x10
  generateCloudShape(COUNT),  // 1: nuage
  generateComputerShape(COUNT), // 2: ordinateur
  generateCloudShape(COUNT),  // 3: nuage
  generateRouterShape(COUNT), // 4: routeur
  generateCloudShape(COUNT),  // 5: nuage
  generateCodeSymbolShape(COUNT),   // 6: "#"
  generateCloudShape(COUNT),  // 7: nuage
  generateAtShape(COUNT),  // 8: "3D"
  generateCloudShape(COUNT),  // 9: nuage
  generateHeartShape(COUNT)   // 10: c≈ìur
];





const geometry = new THREE.BoxGeometry(1,1,1);

for(let i=0;i<COUNT;i++){
  const hue = 0.5 + (0.8-0.5)*(i/COUNT); // cyan ‚Üí magenta
  const mat = new THREE.MeshStandardMaterial({
    color: new THREE.Color().setHSL(hue,1,0.5),
    metalness:0.9,
    roughness:0.1
  });
  const c = new THREE.Mesh(geometry, mat);
cubeGroup.add(c); 
  cubes.push(c);
}









cubeGroup.scale.set(0.05, 0.05, 0.05);    // r√©duire l‚Äô√©chelle globale








// table de s√©quences de morphing

const morphSequences = [
  { start: 0.0, end: 0.1, from: 0, to: 0 }, // cube PAUSE
  { start: 0.1, end: 0.15, from: 0, to: 2 }, // cube ‚Üí ordinateur
  { start: 0.15, end: 0.25, from: 2, to: 2 }, // ordinateur PAUSE
  { start: 0.25, end: 0.35, from: 2, to: 4 }, // ordinateur ‚Üí routeur
  { start: 0.35, end: 0.45, from: 4, to: 4 }, // routeur PAUSE
  { start: 0.45, end: 0.55, from: 4, to: 6 }, // routeur ‚Üí 3D
  { start: 0.55, end: 0.65, from: 6, to: 6 }, //  3D PAUSE
  { start: 0.65, end: 0.75, from: 6, to: 8 }, // 3D ‚Üí "#"
  { start: 0.75, end: 0.85, from: 8, to: 8 }, // "#" PAUSE
  { start: 0.85, end: 0.95, from: 8, to: 10 }, // "#" ‚Üí c≈ìur
  { start: 0.95, end: 1.0, from: 10, to: 10 } // c≈ìur PAUSE
];



function getCurrentShape(sf) {
  for (const seq of morphSequences) {
    if (sf >= seq.start && sf < seq.end) return seq.shapeIndex;
  }
  return shapes.length - 1; // fallback ‚Üí derni√®re forme
}


function animateMorphing(sf) {
    const seq = morphSequences.find(s => sf >= s.start && sf <= s.end);
    if (!seq) return;

    let localT = (seq.from === seq.to) ? 0 : THREE.MathUtils.clamp((sf - seq.start)/(seq.end - seq.start),0,1);

    const a = shapes[seq.from];
    const b = shapes[seq.to];

    for (let i = 0; i < COUNT; i++) {
        const pa = a[i] ?? {x:0,y:0,z:0};
        const pb = b[i] ?? pa;

        cubes[i].position.set(
            THREE.MathUtils.lerp(pa.x, pb.x, localT),
            THREE.MathUtils.lerp(pa.y, pb.y, localT),
            THREE.MathUtils.lerp(pa.z, pb.z, localT)
        );
    }
}





cubeGroup.position.set(0, 0, 0);        // centre au milieu de la sc√®ne





//============================================================================================================
// TEXTE    TEXTE    TEXTE    TEXTE    TEXTE    TEXTE   TEXTE    TEXTE    TEXTE    TEXTE    TEXTE    TEXTE    TEXTE
//============================================================================================================


// === TEXTES 3D===
const textMeshes = [];
const fontLoader = new FontLoader();
fontLoader.load(
  "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
  (font) => {
    const texts = [
      { text: "    Axel\nLASALVIA", pos: [-1.5, 2, -0.5], size: 0.4, speed: 1.0, description: "" },
      { text: "Technicien HELPDESK\n   Developpeur Web", pos: [-2.7, -2.5, -5], size: 0.4, speed: 1.0, description: "" },
      { text: "NETWORK", pos: [1.5, -2, 8], size: 0.6, speed: 1, description: "We are committed to harnessing clean and sustainable energy solutions, ensuring that every drop of water we manage contributes to a greener future. Our innovative approach supports communities while reducing environmental impact.", color: "#002244" },
      { text: "HARDWARE", pos: [-10, 2, 3], size: 0.8, speed: 1, description: "Water is the foundation of life. We work closely with agricultural partners to ensure safe and reliable water access, helping to nourish populations and promote food security around the world.", color: "#002244" },
      { text: "3D WEB & DESIGN", pos: [-3, -14, -8], size: 0.6, speed: 1.5, description: "Water is the essence of life. We are dedicated to safeguarding this precious resource, ensuring its purity, accessibility, and sustainability for communities and ecosystems around the world.", color: "#002244" },
      { text: "LANGUAGES", pos: [8, -5.5, -3.5], size: 0.7, speed: 1, description: "PYTHON ****\nTHREEJS ***\nJAVASCRIPT ***\nVBA **\NBAT **", color: "#002244" },
      { text: "LET'S WORK", pos: [-8, -22.5, 2.8], size: 0.7, speed: 1.7, description: "", color: "#002244" },
      { text: "TOGETHER", pos: [-8, -24, 2.5], size: 0.7, speed: 1.7, description: "E X P L O R E\n\n‚¨áÔ∏è\n\nW E B S I T E", color: "#002244" }

    ];

    texts.forEach((t) => {
      const geom = new TextGeometry(t.text, {
        font: font,
        height: 0.05,
        height: 0.025,
        size: t.size ?? 0.4,
        bevelEnabled: true,
        bevelThickness: 0.003,
        bevelSize: 0.002,
        bevelSegments: 4,
        curveSegments: 10
    });


    const COLOR_LEFT  = new THREE.Color(0x002244); // bleu fonc√©
    const COLOR_RIGHT = new THREE.Color(0x660033); // magenta fonc√©


    // === D√âGRAD√â CYAN ‚Üí MAGENTA ===
    geom.computeBoundingBox();

    const bbox = geom.boundingBox;
    const sizeX = bbox.max.x - bbox.min.x;

    const colors = [];
    const pos = geom.attributes.position;

    for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const t = (x - bbox.min.x) / sizeX; // 0 ‚Üí 1

    const c = COLOR_LEFT.clone().lerp(COLOR_RIGHT, t);
    colors.push(c.r, c.g, c.b);
    }

    geom.setAttribute(
    'color',
    new THREE.Float32BufferAttribute(colors, 3)
    );


    let mat;

    // TEXTE CYBER D√âGRAD√â
    if (
      t.text === "Technicien HELPDESK\n   Developpeur Web" ||
      t.text === "    Axel\nLASALVIA"
    ) {
      mat = new THREE.MeshStandardMaterial({
          vertexColors: true,
          metalness: 0.9,
          roughness: 0.1,
          emissive: new THREE.Color(0x000000)
      });
    } else {
      mat = new THREE.MeshStandardMaterial({
          color: 0x55aaff,
          metalness: 0.9,
          roughness: 0.1
      });
    }


    const mesh = new THREE.Mesh(geom, mat);
    mesh.userData.label = t.text;
    mesh.userData.description = "";
    mesh.userData.color = t.color || "#fff";
    mesh.position.set(...t.pos);
    mesh.userData.baseY = t.pos[1];
    mesh.userData.speed = t.speed;

    // ‚úÖ clone seulement si n√©cessaire, et assure-toi que l‚Äôemissive est correct
    mesh.material = mat.clone();
    mesh.material.emissive = mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000);
    mesh.material.emissiveIntensity = 0.4; // valeur initiale

    scene.add(mesh);
    textMeshes.push(mesh);




      // Configurations sp√©cifiques conserv√©es

      if (t.text === "    Axel\nLASALVIA") {
        mesh.rotation.x = Math.PI / 8;
        mesh.scale.set(1.2, 1.2, 1.2);
      }

      if (t.text === "Technicien HELPDESK\n   Developpeur Web") {
        mesh.rotation.x = Math.PI / 10;
      }

      if (t.text === "NETWORK") {
        mesh.rotation.y = Math.PI;
        mesh.material.color.set(0x002244);
        mesh.material.emissive.set(0x002244);
        mesh.material.emissiveIntensity = 1;
      }

      if (t.text === "HARDWARE") {
        mesh.rotation.y = Math.PI / 2;
        mesh.material.color.set(0x002244);
        mesh.material.emissive.set(0x002244);
        mesh.material.emissiveIntensity = 0.6;
      }

      if (t.text === "3D WEB & DESIGN") {
        mesh.rotation.y = -Math.PI / 100;
        mesh.material.color.set(0x002244);
        mesh.material.emissive.set(0x002244);
        mesh.material.emissiveIntensity = 0.6;
      }

      if (t.text === "LANGUAGES") {
        mesh.rotation.y = -Math.PI /2;
        mesh.material.color.set(0x002244);
        mesh.material.emissive.set(0x002244);
        mesh.material.emissiveIntensity = 0.6;
      }

      if (t.text === "LET'S WORK") {
        mesh.rotation.y = Math.PI / 2;
        mesh.material.color.set(0x002244);
        mesh.material.emissive.set(0x002244);
        mesh.material.emissiveIntensity = 0.6;
      }

      if (t.text === "TOGETHER") {
        mesh.rotation.y = Math.PI / 2;
        mesh.material.color.set(0x002244);
        mesh.material.emissive.set(0x002244);
        mesh.material.emissiveIntensity = 0.6;
      }


    });
  }
);







// === ZONES DE TEXTE AU SCROLL === POUR BOX ET LUMIERE !!

const scrolltextbox = [
  


  {
    label: "HARDWARE",
    start: 0.15,
    end: 0.25
  },
  {
    label: "NETWORK",
    start: 0.35,
    end: 0.45
  },
  {
    label: "3D WEB & DESIGN",
    start: 0.55,
    end: 0.65
  },
  {
    label: "LANGUAGES",
    start: 0.75,
    end: 0.85
  },
  {
    label: "TOGETHER",
    start: 0.96,
    end: 1
  }
  
];

/*
// === CLASSE POUR LES BULLES ===
class InfoBubble {
    updateResponsiveLayout() {
        const w = 0;
        const h = 0;

        // facteur global
        const scale = Math.min(w / 1200, h / 800);

        // limites pour √©viter extr√™mes
        const clampedScale = Math.max(0, Math.min(scale, 0));

        const bubbleSize = 600 * clampedScale;
        const fontSize = 3 * clampedScale;

        this.container.style.width = `${bubbleSize}px`;
        this.container.style.height = `${bubbleSize}px`;
        this.text.style.fontSize = `${fontSize}em`;

        // position mobile
        if (w < 768) {
            this.container.style.top = '75%';
        } else {
            this.container.style.top = '80%';
        }
        }

  constructor() {
    this.container = document.createElement('div');
    this.container.style.position = 'fixed';
    this.container.style.top = '90%';
    this.container.style.left = '50%';
    this.container.style.transform = 'translate(-50%, -50%) scale(0.8)';
    this.container.style.width = '0px';
    this.container.style.height = '0px';
    this.container.style.borderRadius = '0';
    this.container.style.background = 'rgba(255,255,255,0.04)';
    this.container.style.color = '#fff';
    this.container.style.fontFamily = 'OCR A Std, monospace';
    this.container.style.display = 'flex';
    this.container.style.flexDirection = 'column';
    this.container.style.alignItems = 'center';
    this.container.style.justifyContent = 'center';
    this.container.style.backdropFilter = 'blur(10px)';
    this.container.style.border = '2px solid rgba(255,255,255,0.3)';
    this.container.style.opacity = '0';
    this.container.style.transition = 'opacity 0.5s, transform 0.5s';
    document.body.appendChild(this.container);

    this.text = document.createElement('div');
    this.text.style.textAlign = 'center';
    this.text.style.fontWeight = '700';
    this.text.style.fontSize = '1.5em';
    this.container.appendChild(this.text);

    this.updateResponsiveLayout();
    window.addEventListener('resize', () => this.updateResponsiveLayout());
  }

  show(message, color = "#fff") { // ‚Üê on ajoute color
    this.text.innerText = message;

    this.text.style.background = 'linear-gradient(90deg, #005f6a, #5a006a)';
    this.text.style.webkitBackgroundClip = 'text';
    this.text.style.backgroundClip = 'text';
    this.text.style.webkitTextFillColor = 'transparent';


    this.container.style.opacity = '0.9';
    this.container.style.transform = 'translate(-50%, -50%) scale(1)';
  }


  hide() {
    this.container.style.opacity = '0';
    this.container.style.transform = 'translate(-50%, -50%) scale(0.8)';
  }
  
}

const bubble = new InfoBubble();
*/
//======================================================================================================================================
//   BULLE MENU 
//=======================================================================================================================================

// --- FONCTION POUR METTRE LE CONTENU DE LA BULLE ---
function setBubbleContent(text, image) {
  const bubbleText = document.getElementById("bubbleText");
  const bubbleImage = document.getElementById("bubbleImage");

  if (!bubbleText || !bubbleImage) return;

  bubbleText.innerHTML = text ?? "";


  if (image) {
    bubbleImage.src = image;
    bubbleImage.style.display = "block";
  } else {
    bubbleImage.style.display = "none";
  }
}


// --- BULLE INFO ---
const infoBubble = document.getElementById("infoBubble");

function showBubble() {
  if (!infoBubble) return;
  infoBubble.classList.add("visible");
}

function hideBubble() {
  if (!infoBubble) return;
  infoBubble.classList.remove("visible");
}

// Cache au scroll
window.addEventListener(
  "scroll",
  () => {
    hideBubble();
  },
  { passive: true }
);

// Cache au clic hors bulle / hors boutons menu
document.addEventListener("click", (e) => {
  if (!infoBubble) return;

  // clic dans la bulle ‚Üí on ne ferme pas
  if (e.target.closest("#infoBubble")) return;

  // clic sur un bouton du menu ‚Üí on ne ferme pas
  if (e.target.closest(".menuBubble button")) return;

  hideBubble();
});

// Mobile : m√™me logique
document.addEventListener(
  "touchstart",
  (e) => {
    if (!infoBubble) return;

    if (e.target.closest("#infoBubble")) return;
    if (e.target.closest(".menuBubble button")) return;

    hideBubble();
  },
  { passive: true }
);





// --- Donn√©es des menus ---
const menuBubbles = [];
const menuData = [
  { id: "menu1", buttons: ["MONTAGE", "INSTALLATION", "REPARATION"] },
  { id: "menu2", buttons: ["DEPLOIMENT", "SECURITE", "CERTIFICATIONS"] },
  { id: "menu3", buttons: ["PYTHON", "JAVASCRIPT / THREEJS", "VBA", "BATCH"] },
  { id: "menu4", buttons: ["BLENDER","BLENDER + PYTHON", "3D WEB", "3D ASSETS", "SOCIAL NETWORK ADV"] },
  { id: "menu5", buttons: ["CV", "CONTACT", "A PROPOS DE CE SITE"] }
];

// --- Donn√©es des bulles ---
const bubbleData = {
  "MONTAGE": { text: "Montage et assemblage de postes informatiques et de composants mat√©riels (PC fixes, p√©riph√©riques, √©l√©ments r√©seau). Choix des composants adapt√©s √† l‚Äôusage, souci de compatibilit√© et de fiabilit√©.", image: "images/hardware1.png" },
  "INSTALLATION": { text: "Installation mat√©rielle de postes de travail et √©quipements informatiques : mise en place physique, raccordement, v√©rification du bon fonctionnement et pr√©paration √† l‚Äôexploitation.", image: "images/hardware2.png" },
  "REPARATION": { text: "Diagnostic et r√©paration de pannes mat√©rielles de niveau N1/N2 : remplacement de composants, identification des d√©faillances courantes et remise en service rapide des √©quipements.", image: "images/hardware3.png" },
  "DEPLOIMENT": { text: "D√©ploiement et mise en service de r√©seaux locaux : configuration de base des √©quipements (routeur, switch, postes), adressage IP, tests de connectivit√© et assistance aux utilisateurs. Intervention dans le cadre d‚Äôun support r√©seau N1/N2.", image: "images/network1.png" },
  "SECURITE": { text: "Application des bonnes pratiques de s√©curit√© informatique et r√©seau : gestion des acc√®s, s√©curisation des postes, sauvegardes, et sensibilisation aux risques courants en environnement professionnel.", image: "images/network2.png" },
  "CERTIFICATIONS": { text:  `
      Certifications professionnelles obtenues avec la
      <a href="https://www.cisco.com" target="_blank" rel="noopener noreferrer">
        WebAcad√©mie CISCO
      </a>.
    `, image: "images/network3.gif" },
  "BLENDER": { text: "Cr√©ation et manipulation de sc√®nes 3D avec Blender : mod√©lisation, optimisation et int√©gration orient√©es jeux vid√©o et web.", image: "images/web1.gif" },
  "3D WEB": { text: "D√©veloppement d‚Äôexp√©riences 3D interactives pour le web, combinant performance, esth√©tique et interactivit√©, notamment via Three.js.", image: "images/web3d.png" },
  "3D ASSETS": { text: `Cr√©ation d‚Äôassets 3D optimis√©s pour jeux vid√©o et partag√©s sur la plateforme <a href="https://steamcommunity.com/profiles/76561198331605302/" target="_blank" rel="noopener noreferrer">
        STEAM
      </a>`, image: "images/assets.gif" },
  "BLENDER + PYTHON": { text: `
    <div class="youtube-wrapper">
        <iframe
        src="https://www.youtube.com/embed/VNFjnPUGfRc?si=DN72HD7q13_rerQ7"
        title="YouTube video player"
        allowfullscreen>
        </iframe>
    </div>
    Mise en forme et visualisation de donn√©es techniques pour faciliter la compr√©hension et l'apprentissage. Voir le script Python sur <a href="https://github.com/AxeLibre/Compteur-Binaire-Hexa-pour-Blender" target="_blank" rel="noopener noreferrer">
        GitHub
      </a>`, image: "images/none.png" },
  "SOCIAL NETWORK ADV": { text: "Cr√©ation de contenus publicitaires orient√©s esth√©tique et impact visuel pour les r√©seaux sociaux. Approche ax√©e sur le message, le design et la mise en valeur des produits ou services, avec une compr√©hension des codes commerciaux des plateformes.", image: "images/none.png" },
  "PYTHON": { text: "D√©veloppement d‚Äôoutils et d‚Äôapplications en Python, notamment pour l‚Äôautomatisation, l‚Äôanalyse r√©seau et la cr√©ation d‚Äôinterfaces graphiques.", image: "images/python.png" },
  "JAVASCRIPT / THREEJS": { text: "Applications Web interactives avec JS et Three.js.", image: "images/js.png" },
  "VBA": { text: "Automatisation de t√¢ches et cr√©ation d‚Äôoutils personnalis√©s sous Excel pour gagner du temps et fiabiliser les processus.", image: "images/vba.png" },
  "BATCH": { text: "Scripts batch pour l‚Äôautomatisation syst√®me, le d√©ploiement rapide et la maintenance en environnement Windows.", image: "images/batch.png" },
  "CV": { text: `<a href="cv/CV_Axel_LASALVIA_2026.pdf" target="_blank" rel="noopener">
  Consultez mon CV en ligne
  </a><br>
  Consultez mon CV sur Linkdeen.`, image: "images/cv.png" },
  "CONTACT": { text: "Me contacter directement.", image: "images/contact.png" },
  "A PROPOS DE CE SITE": { text: "Informations sur la cr√©ation de ce site.", image: "images/info.png" }
};

// --- Cr√©ation des menus et boutons ---
menuData.forEach(m => {
  const div = document.createElement("div");
  div.className = "menuBubble";
  div.id = m.id;
  div.style.position = "fixed";
  div.style.top = "80%";
  div.style.left = "50%";
  div.style.transform = "translate(-50%, -50%)";
  div.style.padding = "10px";
  div.style.borderRadius = "5px";
  div.style.border = "1px solid rgba(255,255,255,0.25)";
  div.style.background = div.style.background ="linear-gradient(135deg, rgba(0,198,255,0.5), rgba(143,0,255,0.5))";
  div.style.color = "#fff";
  div.style.display = "none";
  div.style.zIndex = 20;
  div.style.textAlign = "center";
  div.style.fontFamily = "Garamond, serif";
  div.style.maxWidth = "90vw";
  div.style.width = "auto";
  div.style.boxSizing = "border-box";
  div.style.backdropFilter = "blur(8px)";
  div.style.webkitBackdropFilter = "blur(8px)";

  m.buttons.forEach(b => {
    const btn = document.createElement("button");
    btn.innerText = b;
    btn.style.margin = "5px";
    btn.style.width = "260px";          // largeur fixe
    btn.style.maxWidth = "80vw";        // s√©curit√© mobile
    btn.style.padding = "14px 0";       // hauteur du bouton
    btn.style.borderRadius = "4px";
    btn.style.border = "1px solid rgba(255,255,255,0.7)";
    btn.style.cursor = "pointer";
    btn.style.background = "linear-gradient(135deg, #00c6ff, #8f00ff)";
    btn.style.backgroundSize = "200% 200%";
    btn.style.transition = "background-position 0.6s ease, transform 0.2s";
    btn.style.color = "#001616";                 // couleur du texte
    btn.style.fontFamily = "Inter, system-ui";   // police moderne
    btn.style.fontSize = "clamp(14px, 2.5vw, 18px)";
    btn.style.fontWeight = "500";                // 400 = normal, 600 = semi-bold
    btn.style.letterSpacing = "0.04em";          // respiration du texte
    btn.style.textTransform = "uppercase";       // optionnel mais styl√©


    // Lien du bouton vers sa bulle
    btn.addEventListener("click", () => {
      const data = bubbleData[b];
      if (!data) return;
      setBubbleContent(data.text, data.image);
      showBubble();
    });

    // Hover effet
    btn.addEventListener("mouseenter", () => {
      btn.style.backgroundPosition = "100% 50%";
      btn.style.transform = "scale(1.05)";
    });
    btn.addEventListener("mouseleave", () => {
      btn.style.backgroundPosition = "0% 50%";
      btn.style.transform = "scale(1)";
    });

    div.appendChild(btn);
  });

  document.body.appendChild(div);
  menuBubbles.push(div);
});


function updateMenuBubbles(sf) {
    hideBubble();

  const ranges = [
    [0.17, 0.23], // menu1
    [0.37, 0.43], // menu2
    [0.57, 0.63], // menu3
    [0.77, 0.83], // menu4
    [0.96, 1.01]  // menu5
  ];

  menuBubbles.forEach((div, i) => {
    const [start, end] = ranges[i];
    const fade = 0.05; // dur√©e du fondu

    if (sf < start - fade || sf > end + fade) {
      div.style.display = "none";
      div.style.opacity = 0;
      return;
    }

    div.style.display = "block";

    if (sf < start) {
      // fade-in
      div.style.opacity = (sf - (start - fade)) / fade;
    } 
    else if (sf > end) {
      // fade-out
      div.style.opacity = 1 - (sf - end) / fade;
    } 
    else {
      // visible plein
      div.style.opacity = 1;
    }
  });
}









// === POST-PROCESSING ===
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.35, 0.25);
composer.addPass(bloomPass);

// === SCROLL LISSE ===
let scrollFactor = 0;       // valeur r√©elle du scroll
let smoothScroll = 0;       // valeur interpol√©e pour lisser
const smoothFactor = 0.08;  // plus petit = plus doux

window.addEventListener("scroll", () => {
  const maxScroll = document.body.scrollHeight - window.innerHeight;
  
  // Calcul du scroll factor normalis√© (0 ‚Üí 1)
  scrollFactor = Math.min(Math.max(window.scrollY / maxScroll, 0), 1);

  updateMenuBubbles(scrollFactor);

});


//Fonction d√©di√©e : mont√©e du texte au scroll
function animateTechText(mesh, sf) {
  const SCROLL_START = 0.05;
  const SCROLL_END   = 0.5; // fin de la mont√©e
  const START_Y = mesh.userData.baseY;
  const END_Y   = START_Y + 15; // hauteur de mont√©e (ajuste si besoin)

  if (sf <= SCROLL_START) {
    mesh.position.y += (START_Y - mesh.position.y) * 0.1;
    return;
  }

  const t = THREE.MathUtils.clamp(
    (sf - SCROLL_START) / (SCROLL_END - SCROLL_START),
    0,
    1
  );

  // easing doux (cin√©matique)
  const ease = 1 - Math.pow(1 - t, 3);

  const targetY = THREE.MathUtils.lerp(START_Y, END_Y, ease);
  mesh.position.y += (targetY - mesh.position.y) * 0.1;
}




let activeText = null;

const HORIZON_Y = 0; // hauteur du "plan narratif"

const BLOOM_LAYER = 1;
camera.layers.enable(BLOOM_LAYER);



// === √âCOUTEUR DE SOURIS ===
window.addEventListener('mousemove', (event) => {
  // Normaliser les coordonn√©es de la souris (-1 √† 1)
  targetMousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
  targetMousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
});



//======================================================================================================================================
// === ANIMATION =======================================================================================================================
function animate() {
  requestAnimationFrame(animate);

  if (!ready) return; // ne pas rendre tant que la sc√®ne n'est pas pr√™te
  if (!renderer.domElement.classList.contains('visible')) {
    renderer.domElement.classList.add('visible');
  }

// === RECALCUL SCROLL FACTOR ===
const maxScroll = document.body.scrollHeight - window.innerHeight;
scrollFactor = Math.min(Math.max(window.scrollY / maxScroll, 0), 1);

// Lissage pour un scroll plus doux
smoothScroll += (scrollFactor - smoothScroll) * smoothFactor;
const sf = smoothScroll; // sf √† utiliser partout



  let newActive = null;





  

  // === CAM√âRA ===
    // radius s'adapte √† la largeur √©cran
let radius = 8;
if (window.innerWidth / window.innerHeight > 2) radius = 5;

const angle = sf * Math.PI * 2.5;
const camX = Math.sin(angle) * radius;
const camZ = Math.cos(angle) * radius;

camera.position.set(camX, HORIZON_Y, camZ);
camera.lookAt(0, HORIZON_Y, 0);





// === SUIVI DU CUBE AVEC LA CAM√âRA (INERTIE) ===

// position verticale cible selon le scroll
const targetY = THREE.MathUtils.lerp(1.2, -1.2, sf);

// interpolation douce
cameraAnchor.position.y +=
  (targetY - cameraAnchor.position.y) * 0.08;




// === POSITION DES FORMES √Ä DROITE DE L'√âCRAN ===

// position √©cran (NDC)
// x = 1 ‚Üí droite de l‚Äô√©cran
// y = 0 ‚Üí centre vertical
// z = 0.5 ‚Üí profondeur (devant la cam√©ra)
const screenPos = new THREE.Vector3(0, 0, 0);

// conversion √©cran ‚Üí monde
screenPos.unproject(camera);

// direction depuis la cam√©ra
const dir = screenPos.sub(camera.position).normalize();

// distance fixe devant la cam√©ra
const distance = 6;

// position finale
cubeGroup.position.copy(
  camera.position.clone().add(dir.multiplyScalar(distance))
);









 // === TEXTE ===
textMeshes.forEach(mesh => {

  // Mont√© du texte apr√®s passage du scroll
  if (mesh.userData.label === "Technicien HELPDESK\n   Developpeur Web") {
    animateTechText(mesh, sf);
    return;
  }
  if (mesh.userData.label === "    Axel\nLASALVIA") {
    animateTechText(mesh, sf);
    return;
  }

  // COMPORTEMENT NORMAL DES AUTRES TEXTES
  const targetY = mesh.userData.baseY + sf * 16 * mesh.userData.speed;
  mesh.position.y += (targetY - mesh.position.y) * 0.1;
});










// === EMISSIVE TEXTE (pilot√© par le scroll) ===
textMeshes.forEach(mesh => {
  // D√©finir une plage d'activation pour chaque texte (0 ‚Üí d√©but scroll, 1 ‚Üí fin scroll)
  let start = 0, end = 1; // valeurs par d√©faut
  switch(mesh.userData.label) {
    case "HARDWARE": start = 0.18; end = 0.23; break;
    case "NETWORK": start = 0.38; end = 0.43; break;
    case "3D WEB & DESIGN": start = 0.78; end = 0.83; break;
    case "LANGUAGES": start = 0.58; end = 0.63; break;
    case "TOGETHER": start = 0.97; end = 1.01; break;
    // ajoute d'autres textes si n√©cessaire
  }

  // Est-ce que le scroll est dans la plage ?
  const isActive = sf >= start && sf <= end;
  const targetEmissiveIntensity = isActive ? 2.5 : 0.4;

  // D√©grad√© √©missif sp√©cifique pour certains textes
  if (["HARDWARE", "NETWORK", "3D WEB & DESIGN", "LANGUAGES", "TOGETHER"].includes(mesh.userData.label)) {
    const emissiveOn = new THREE.Color(0xA30056);
    const emissiveOff = new THREE.Color(0x000000);
    mesh.material.emissive.lerp(isActive ? emissiveOn : emissiveOff, 0.05);
  }

  // Applique toujours l‚Äôintensit√©
  mesh.material.emissiveIntensity += (targetEmissiveIntensity - mesh.material.emissiveIntensity) * 0.1;
});


// Rendu bloom SEUL
camera.layers.set(BLOOM_LAYER);

composer.render();
animateMorphing(sf);
const time = performance.now() * 0.001;
const floatAmplitude = 0.10;

const baseHeight = 0;


cubeGroup.position.y =
  baseHeight +
  Math.sin(time) * floatAmplitude; // üí´ flottement vertical doux

cubeGroup.rotation.y += 0.003; // üí´ rotation douce

/*
// === ANIMATION DES CUBES DE SOURIS ===
const currentTime = performance.now();
const deltaTime = lastTime ? (currentTime - lastTime) / 1000 : 0.016;
lastTime = currentTime;

updateMouseCubes(deltaTime);
*/


// Rendu normal
camera.layers.set(0);
renderer.render(scene, camera);




}

animate();

</script>

</body>
</html>

